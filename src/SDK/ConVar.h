#pragma once

//-----------------------------------------------------------------------------
// ConVar flags
//-----------------------------------------------------------------------------
// The default, no flags at all
#define FCVAR_NONE				0 

// Command to ConVars and ConCommands
// ConVar Systems
#define FCVAR_UNREGISTERED		(1<<0)	// If this is set, don't add to linked list, etc.
#define FCVAR_DEVELOPMENTONLY	(1<<1)	// Hidden in released products. Flag is removed automatically if ALLOW_DEVELOPMENT_CVARS is defined.
#define FCVAR_GAMEDLL			(1<<2)	// defined by the game DLL
#define FCVAR_CLIENTDLL			(1<<3)  // defined by the client DLL
#define FCVAR_HIDDEN			(1<<4)	// Hidden. Doesn't appear in find or auto complete. Like DEVELOPMENTONLY, but can't be compiled out.

// ConVar only
#define FCVAR_PROTECTED			(1<<5)  // It's a server cvar, but we don't send the data since it's a password, etc.  Sends 1 if it's not bland/zero, 0 otherwise as value
#define FCVAR_SPONLY			(1<<6)  // This cvar cannot be changed by clients connected to a multiplayer server.
#define	FCVAR_ARCHIVE			(1<<7)	// set to cause it to be saved to vars.rc
#define	FCVAR_NOTIFY			(1<<8)	// notifies players when changed
#define	FCVAR_USERINFO			(1<<9)	// changes the client's info string

#define FCVAR_PRINTABLEONLY		(1<<10)  // This cvar's string cannot contain unprintable characters ( e.g., used for player name etc ).

#define FCVAR_GAMEDLL_FOR_REMOTE_CLIENTS	(1<<10)  // When on concommands this allows remote clients to execute this cmd on the server. 
													 // We are changing the default behavior of concommands to disallow execution by remote clients without
													 // this flag due to the number existing concommands that can lag or crash the server when clients abuse them.

#define FCVAR_UNLOGGED			(1<<11)  // If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log
#define FCVAR_NEVER_AS_STRING	(1<<12)  // never try to print that cvar

// It's a ConVar that's shared between the client and the server.
// At signon, the values of all such ConVars are sent from the server to the client (skipped for local
//  client, of course )
// If a change is requested it must come from the console (i.e., no remote client changes)
// If a value is changed while a server is active, it's replicated to all connected clients
#define FCVAR_REPLICATED		(1<<13)	// server setting enforced on clients, TODO rename to FCAR_SERVER at some time
#define FCVAR_CHEAT				(1<<14) // Only useable in singleplayer / debug / multiplayer & sv_cheats
#define FCVAR_SS				(1<<15) // causes varnameN where N == 2 through max splitscreen slots for mod to be autogenerated
#define FCVAR_DEMO				(1<<16) // record this cvar when starting a demo file
#define FCVAR_DONTRECORD		(1<<17) // don't record these command in demofiles
#define FCVAR_SS_ADDED			(1<<18) // This is one of the "added" FCVAR_SS variables for the splitscreen players
#define FCVAR_RELEASE			(1<<19) // Cvars tagged with this are the only cvars avaliable to customers
#define FCVAR_RELOAD_MATERIALS	(1<<20)	// If this cvar changes, it forces a material reload
#define FCVAR_RELOAD_TEXTURES	(1<<21)	// If this cvar changes, if forces a texture reload

#define FCVAR_NOT_CONNECTED		(1<<22)	// cvar cannot be changed by a client that is connected to a server
#define FCVAR_MATERIAL_SYSTEM_THREAD (1<<23)	// Indicates this cvar is read from the material system thread
#define FCVAR_ARCHIVE_GAMECONSOLE	(1<<24) // cvar written to config.cfg on the Xbox

#define FCVAR_SERVER_CAN_EXECUTE	(1<<28)// the server is allowed to execute this command on clients via ClientCommand/NET_StringCmd/CBaseClientState::ProcessStringCmd.
#define FCVAR_SERVER_CANNOT_QUERY	(1<<29)// If this is set, then the server is not allowed to query this cvar's value (via IServerPluginHelpers::StartQueryCvarValue).
#define FCVAR_CLIENTCMD_CAN_EXECUTE	(1<<30)	// IVEngineClient::ClientCmd is allowed to execute this command. 
											// Note: IVEngineClient::ClientCmd_Unrestricted can run any client command.

#define FCVAR_ACCESSIBLE_FROM_THREADS	(1<<25)	// used as a debugging tool necessary to check material system thread convars
// #define FCVAR_AVAILABLE			(1<<26)
// #define FCVAR_AVAILABLE			(1<<27)
// #define FCVAR_AVAILABLE			(1<<31)

#define FCVAR_MATERIAL_THREAD_MASK ( FCVAR_RELOAD_MATERIALS | FCVAR_RELOAD_TEXTURES | FCVAR_MATERIAL_SYSTEM_THREAD )	

class ConCommandBase
{
public:
	void*			vt;
	ConCommandBase* m_pNext;
	bool			m_bRegistered;
	const char*		m_pszName;
	const char*		m_pszHelpString;
	int				m_nFlags;

	~ConCommandBase()
	{
		I::Cvar->UnregisterConCommand(this);
	}
	
	inline void Create(const char* pName, const char* pHelpString = nullptr, int flags = 0)
	{
		static const ConCommandBase* dummy = I::Cvar->FindCommandBase("quit");
		vt = dummy->vt;

		typedef void(__thiscall* Fn)(ConCommandBase*, const char*, const char*, int);
		GetVF<Fn>(this, 10)(this, pName, pHelpString, flags);
	}
};

#pragma region CCommand

enum cmd_source_t
{
	// Added to the console buffer by gameplay code.  Generally unrestricted.
	kCommandSrcCode,

	// Sent from code via engine->ClientCmd, which is restricted to commands visible
	// via FCVAR_CLIENTCMD_CAN_EXECUTE.
	kCommandSrcClientCmd,

	// Typed in at the console or via a user key-bind.  Generally unrestricted, although
	// the client will throttle commands sent to the server this way to 16 per second.
	kCommandSrcUserInput,

	// Came in over a net connection as a clc_stringcmd
	// host_client will be valid during this state.
	//
	// Restricted to FCVAR_GAMEDLL commands (but not convars) and special non-ConCommand
	// server commands hardcoded into gameplay code (e.g. "joingame")
	kCommandSrcNetClient,

	// Received from the server as the client
	//
	// Restricted to commands with FCVAR_SERVER_CAN_EXECUTE
	kCommandSrcNetServer,

	// Being played back from a demo file
	//
	// Not currently restricted by convar flag, but some commands manually ignore calls
	// from this source.  FIXME: Should be heavily restricted as demo commands can come
	// from untrusted sources.
	kCommandSrcDemoFile,

	// Invalid value used when cleared
	kCommandSrcInvalid = -1
};

//struct characterset_t
//{
//	char set[256];
//};
//
//void CharacterSetBuild(characterset_t *pSetBuffer, const char *pszSetString)
//{
//	// Test our pointers
//	if (!pSetBuffer || !pszSetString)
//		return;
//
//	memset(pSetBuffer->set, 0, sizeof(pSetBuffer->set));
//
//	for (unsigned int i = 0; pszSetString[i]; ++i)
//		pSetBuffer->set[pszSetString[i]] = 1;
//}
//
//static characterset_t s_BreakSet;
//static bool s_bBuiltBreakSet = false;

class CCommand
{
public:
	CCommand()
	{
		//if (!s_bBuiltBreakSet)
		//{
		//	s_bBuiltBreakSet = true;
		//	CharacterSetBuild(&s_BreakSet, "{}()':");
		//}

		Reset();
	}

	CCommand(int nArgC, const char** ppArgV, cmd_source_t source)
	{
		assert(nArgC > 0);

		//if (!s_bBuiltBreakSet)
		//{
		//	s_bBuiltBreakSet = true;
		//	CharacterSetBuild(&s_BreakSet, "{}()':");
		//}

		Reset();

		char* pBuf = m_pArgvBuffer;
		char* pSBuf = m_pArgSBuffer;
		m_nArgc = nArgC;
		for (int i = 0; i < nArgC; ++i)
		{
			m_ppArgv[i] = pBuf;

			size_t nLen = strlen(ppArgV[i]);
			memcpy(pBuf, ppArgV[i], nLen + 1);

			if (i == 0)
				m_nArgv0Size = nLen;

			pBuf += nLen + 1;

			bool bContainsSpace = strchr(ppArgV[i], ' ') != NULL;
			if (bContainsSpace)
				*pSBuf++ = '\"';

			memcpy(pSBuf, ppArgV[i], nLen);
			pSBuf += nLen;

			if (bContainsSpace)
				*pSBuf++ = '\"';

			if (i != nArgC - 1)
				*pSBuf++ = ' ';
		}

		m_source = source;
	}

	void Reset()
	{
		m_nArgc = 0;
		m_nArgv0Size = 0;
		m_pArgSBuffer[0] = 0;
		m_source = kCommandSrcInvalid;
	}

	int ArgC() const { return m_nArgc; }
	const char** ArgV() const { return m_nArgc ? (const char**)m_ppArgv : nullptr; }
	const char* ArgS() const { return m_nArgv0Size ? &m_pArgSBuffer[m_nArgv0Size] : ""; }	// All args that occur after the 0th arg, in string form
	const char* GetCommandString() const { return m_nArgc ? m_pArgSBuffer : ""; }	// The entire command in string form, including the 0th arg
	const char* operator[](int nIndex) const { return Arg(nIndex); }	// Gets at arguments
	const char* Arg(int nIndex) const		// Gets at arguments
	{
		// FIXME: Many command handlers appear to not be particularly careful
		// about checking for valid argc range. For now, we're going to
		// do the extra check and return an empty string if it's out of range
		if (nIndex < 0 || nIndex >= m_nArgc)
			return "";
		return m_ppArgv[nIndex];
	}
	inline cmd_source_t Source() const { return m_source; }

	// Helper functions to parse arguments to commands.
	const char* FindArg(const char* pName) const
	{
		int nArgC = ArgC();
		for (int i = 1; i < nArgC; i++)
		{
			if (!_stricmp(Arg(i), pName))
				return (i + 1) < nArgC ? Arg(i + 1) : "";
		}
		return 0;
	}

	int FindArgInt(const char* pName, int nDefaultVal) const
	{
		const char* pVal = FindArg(pName);
		if (pVal)
			return atoi(pVal);
		else
			return nDefaultVal;
	}


	static int MaxCommandLength() { return COMMAND_MAX_LENGTH - 1; }
	//static characterset_t* DefaultBreakSet() { return &s_BreakSet; }

private:
	enum
	{
		COMMAND_MAX_ARGC = 64,
		COMMAND_MAX_LENGTH = 512,
	};

	int			m_nArgc;
	int			m_nArgv0Size;
	char		m_pArgSBuffer[COMMAND_MAX_LENGTH];
	char		m_pArgvBuffer[COMMAND_MAX_LENGTH];
	const char* m_ppArgv[COMMAND_MAX_ARGC];
	cmd_source_t m_source;
};

#pragma endregion

#pragma region ConCommand

//-----------------------------------------------------------------------------
// Called when a ConCommand needs to execute
//-----------------------------------------------------------------------------
typedef void (*FnCommandCallbackV1_t)(void);
typedef void (*FnCommandCallback_t)(const CCommand& command);

#define COMMAND_COMPLETION_MAXITEMS		64
#define COMMAND_COMPLETION_ITEM_LENGTH	64

//-----------------------------------------------------------------------------
// Returns 0 to COMMAND_COMPLETION_MAXITEMS worth of completion strings
//-----------------------------------------------------------------------------
typedef int (*FnCommandCompletionCallback)(const char* partial, char commands[COMMAND_COMPLETION_MAXITEMS][COMMAND_COMPLETION_ITEM_LENGTH]);

//-----------------------------------------------------------------------------
// Interface version
//-----------------------------------------------------------------------------
class ICommandCallback
{
public:
	virtual void CommandCallback(const CCommand& command) = 0;
};

class ICommandCompletionCallback
{
public:
	virtual int  CommandCompletionCallback(const char* pPartial, CUtlVector< CUtlString >& commands) = 0;
};

int DefaultCompletionFunc(const char* partial, char commands[COMMAND_COMPLETION_MAXITEMS][COMMAND_COMPLETION_ITEM_LENGTH])
{
	return 0;
}

class ConCommand : public ConCommandBase
{
public:
	void Create(const char* pName, FnCommandCallbackV1_t callback,
		const char* pHelpString = nullptr, int flags = 0, FnCommandCompletionCallback completionFunc = nullptr)
	{
		m_fnCommandCallbackV1 = callback;
		m_bUsingNewCommandCallback = false;
		m_bUsingCommandCallbackInterface = false;
		m_fnCompletionCallback = completionFunc ? completionFunc : DefaultCompletionFunc;
		m_bHasCompletionCallback = completionFunc != nullptr;

		ConCommandBase::Create(pName, pHelpString, flags);
	}

	void Create(const char* pName, FnCommandCallback_t callback,
		const char* pHelpString = nullptr, int flags = 0, FnCommandCompletionCallback completionFunc = nullptr)
	{
		m_fnCommandCallback = callback;
		m_bUsingNewCommandCallback = true;
		m_bUsingCommandCallbackInterface = false;
		m_fnCompletionCallback = completionFunc ? completionFunc : DefaultCompletionFunc;
		m_bHasCompletionCallback = completionFunc != nullptr;

		ConCommandBase::Create(pName, pHelpString, flags);
	}

	void Create(const char* pName, ICommandCallback* pCallback,
		const char* pHelpString = nullptr, int flags = 0, ICommandCompletionCallback* pCompletionCallback = nullptr)
	{
		m_pCommandCallback = pCallback;
		m_bUsingNewCommandCallback = false;
		m_pCommandCompletionCallback = pCompletionCallback;
		m_bHasCompletionCallback = pCompletionCallback != nullptr;
		m_bUsingCommandCallbackInterface = true;

		ConCommandBase::Create(pName, pHelpString, flags);
	}

	void Dispatch(const CCommand& command)
	{
		if (m_bUsingNewCommandCallback)
		{
			if (m_fnCommandCallback)
			{
				(*m_fnCommandCallback)(command);
				return;
			}
		}
		else if (m_bUsingCommandCallbackInterface)
		{
			if (m_pCommandCallback)
			{
				m_pCommandCallback->CommandCallback(command);
				return;
			}
		}
		else
		{
			if (m_fnCommandCallbackV1)
			{
				(*m_fnCommandCallbackV1)();
				return;
			}
		}

		assert(false && "Encountered ConCommand without a callback!\n");
	}

	union
	{
		FnCommandCallbackV1_t m_fnCommandCallbackV1;
		FnCommandCallback_t m_fnCommandCallback;
		ICommandCallback* m_pCommandCallback;
	};

	union
	{
		FnCommandCompletionCallback	m_fnCompletionCallback;
		ICommandCompletionCallback* m_pCommandCompletionCallback;
	};

	bool m_bHasCompletionCallback : 1;
	bool m_bUsingNewCommandCallback : 1;
	bool m_bUsingCommandCallbackInterface : 1;
};

#pragma endregion

std::vector<ConVar*> g_CreatedConVars;

//-----------------------------------------------------------------------------
// Called when a ConVar changes value
// NOTE: For FCVAR_NEVER_AS_STRING ConVars, pOldValue == NULL
//-----------------------------------------------------------------------------
typedef void (*FnChangeCallback_t)(/*IConVar**/void* var, const char* pOldValue, float flOldValue);

class ConVar : public ConCommandBase
{
public:
	void*		vt;
	ConVar*		m_pParent;
	const char* m_pszDefaultValue;

	char*		m_pszString;
	int			m_StringLength;
	float		m_fValue;
	int			m_nValue;

	bool		m_bHasMin;
	float		m_fMinVal;
	bool		m_bHasMax;
	float		m_fMaxVal;

	CUtlVector< FnChangeCallback_t > m_fnChangeCallbacks;

	~ConVar()
	{
		I::MemAlloc->Free(m_pszString);
	}

	inline float GetFloat()
	{
		uintptr_t hex = reinterpret_cast<uintptr_t>(this) ^ *reinterpret_cast<uintptr_t*>(&m_fValue);
		return *reinterpret_cast<float*>(&hex);
	}

	inline int GetInt()
	{
		return reinterpret_cast<uintptr_t>(this) ^ m_nValue;
	}

	inline const char* GetString()
	{
		return m_pszString;
	}

	inline void SetValue(const char* value)
	{
		typedef void(__thiscall* Fn) (void*, const char*);
		GetVF<Fn>(this, 14)(this, value);
	}

	inline void SetValue(float value)
	{
		typedef void(__thiscall* Fn) (void*, float);
		GetVF<Fn>(this, 15)(this, value);
	}

	inline void SetValue(int value)
	{
		typedef void(__thiscall* Fn) (void*, int);
		GetVF<Fn>(this, 16)(this, value);
	}

	inline void SetValue(Color value)
	{
		typedef void(__thiscall* Fn) (void*, Color);
		GetVF<Fn>(this, 17)(this, value);
	}

	inline void Create(const char* pName, const char* pDefaultValue, int flags = 0,
		const char* pHelpString = nullptr, bool bMin = false, float fMin = 0.f, bool bMax = false, float fMax = 0.f,
		FnChangeCallback_t callback = nullptr)
	{
		static const ConVar* dummy = I::Cvar->FindVar("sensitivity");
		ConCommandBase::vt = dummy->ConCommandBase::vt;
		ConVar::vt = dummy->ConVar::vt;

		typedef void(__thiscall* Fn)(ConVar*, const char*, const char*, int, const char*, bool, float, bool, float, FnChangeCallback_t);
		GetVF<Fn>(this, 20)(this, pName, pDefaultValue, flags, pHelpString, bMin, fMin, bMax, fMax, callback);

		m_nFlags = flags;

		g_CreatedConVars.push_back(this);
	}
};